<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Implementing a Simple Stack in Haskell-Tutorial Island</title>
<meta name=theme-color><meta name=description content="Introduction
Today, we are going to implement a simple stack data structure in Haskell. A stack is a fundamental data structure that follows the Last-In-First-Out (LIFO) principle. This means the last element added to the stack is the first one to be removed. We will implement push, pop, and peek operations to interact with our stack.
Explanation
The main challenge in implementing a stack in Haskell lies in its immutability. We cannot directly modify the stack in place. Instead, each operation will return a new stack."><meta name=author content="Tutorial Island"><link rel="preload stylesheet" as=style href=https://tutorial-island.github.io/main.min.css><link rel=preload as=image href=https://tutorial-island.github.io/theme.png><link rel=preload as=image href=https://tutorial-island.github.io/rss.svg><script defer src=https://tutorial-island.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tutorial-island.github.io/favicon.ico><link rel=apple-touch-icon href=https://tutorial-island.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.146.7"><script async src="https://www.googletagmanager.com/gtag/js?id=G-8LQ7YJEW54"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8LQ7YJEW54")}</script><meta itemprop=name content="Implementing a Simple Stack in Haskell"><meta itemprop=description content="Learn how to implement a basic stack data structure in Haskell with push, pop, and peek operations."><meta itemprop=datePublished content="2025-04-18T00:00:00+00:00"><meta itemprop=dateModified content="2025-04-18T00:00:00+00:00"><meta itemprop=wordCount content="923"><meta itemprop=keywords content="Haskell,Data Structures,Stack,Functional Programming"><meta property="og:url" content="https://tutorial-island.github.io/posts/article-20250418011823/"><meta property="og:site_name" content="Tutorial Island"><meta property="og:title" content="Implementing a Simple Stack in Haskell"><meta property="og:description" content="Learn how to implement a basic stack data structure in Haskell with push, pop, and peek operations."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-18T00:00:00+00:00"><meta property="article:tag" content="Haskell"><meta property="article:tag" content="Data Structures"><meta property="article:tag" content="Stack"><meta property="article:tag" content="Functional Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Simple Stack in Haskell"><meta name=twitter:description content="Learn how to implement a basic stack data structure in Haskell with push, pop, and peek operations."><link rel=canonical href=https://tutorial-island.github.io/posts/article-20250418011823/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://tutorial-island.github.io/>Tutorial Island</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://tutorial-island.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Implementing a Simple Stack in Haskell</h1><div class="text-xs antialiased opacity-60"><time>Apr 18, 2025</time><span class=mx-1>&#183;</span>
<span>Tutorial Island</span></div></header><section><h2 id=introduction>Introduction</h2><p>Today, we are going to implement a simple stack data structure in Haskell. A stack is a fundamental data structure that follows the Last-In-First-Out (LIFO) principle. This means the last element added to the stack is the first one to be removed. We will implement <code>push</code>, <code>pop</code>, and <code>peek</code> operations to interact with our stack.</p><h2 id=explanation>Explanation</h2><p>The main challenge in implementing a stack in Haskell lies in its immutability. We cannot directly modify the stack in place. Instead, each operation will return a <em>new</em> stack.</p><ul><li><strong><code>push</code></strong>: Adding an element to the top of the stack. Since we can&rsquo;t mutate, we&rsquo;ll create a new stack with the element prepended to the existing one.</li><li><strong><code>pop</code></strong>: Removing the top element from the stack. This involves returning both the removed element and the new stack (without the top element). We&rsquo;ll handle the case where the stack is empty.</li><li><strong><code>peek</code></strong>: Viewing the top element without removing it. Similar to <code>pop</code>, we need to handle the case of an empty stack.</li></ul><p>We will represent the stack using a list. Haskell&rsquo;s lists are well-suited for stack operations because adding and removing elements from the head of the list is efficient. We will use type signatures to ensure type safety and pattern matching to elegantly handle different stack states (empty or non-empty). We will also leverage the <code>Maybe</code> type to gracefully handle the empty stack scenarios for <code>pop</code> and <code>peek</code>.</p><h2 id=requirements>Requirements</h2><ul><li>Implement a <code>Stack</code> type using a list.</li><li>Implement a <code>push</code> function to add an element to the top of the stack.</li><li>Implement a <code>pop</code> function to remove and return the top element (and the new stack), or return <code>Nothing</code> if the stack is empty.</li><li>Implement a <code>peek</code> function to return the top element without removing it, or return <code>Nothing</code> if the stack is empty.</li></ul><h2 id=solutions>Solutions</h2><h3 id=pushing-onto-the-stack>Pushing onto the Stack</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>push</span> <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> [a] <span style=color:#f92672>-&gt;</span> [a]
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span> x stack <span style=color:#f92672>=</span> x <span style=color:#66d9ef>:</span> stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> initialStack <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> newStack <span style=color:#f92672>=</span> push <span style=color:#ae81ff>4</span> initialStack
</span></span><span style=display:flex><span>  print newStack
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Assertions (using quickCheck would be more robust in practice)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack1 <span style=color:#f92672>=</span> push <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack2 <span style=color:#f92672>=</span> push <span style=color:#ae81ff>2</span> stack1
</span></span><span style=display:flex><span>  assert (stack1 <span style=color:#f92672>==</span> [<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>  assert (stack2 <span style=color:#f92672>==</span> [<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><p>This <code>push</code> function takes an element <code>x</code> and a stack (represented as a list) and returns a new stack with <code>x</code> added to the <em>head</em> of the list. This effectively pushes the element onto the top of the stack. We are using the list constructor <code>:</code> to prepend the element <code>x</code> to the existing <code>stack</code>.</p><h3 id=popping-from-the-stack>Popping from the Stack</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>pop</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> (a, [a])
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (x, xs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> initialStack <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> popped <span style=color:#f92672>=</span> pop initialStack
</span></span><span style=display:flex><span>  print popped
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Assertions</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack1 <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span>  assert (pop stack1 <span style=color:#f92672>==</span> <span style=color:#66d9ef>Just</span> (<span style=color:#ae81ff>1</span>,[<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]))
</span></span><span style=display:flex><span>  assert (pop stack2 <span style=color:#f92672>==</span> <span style=color:#66d9ef>Nothing</span>)
</span></span></code></pre></div><p>The <code>pop</code> function uses pattern matching to handle two cases: an empty stack (<code>[]</code>) and a non-empty stack (<code>x:xs</code>). If the stack is empty, it returns <code>Nothing</code>. If the stack is not empty, it returns <code>Just (x, xs)</code>, where <code>x</code> is the top element and <code>xs</code> is the rest of the stack (the new stack after popping). We use <code>Maybe</code> to safely represent the possibility of the stack being empty.</p><h3 id=peeking-at-the-stack>Peeking at the Stack</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>peek</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> a
</span></span><span style=display:flex><span><span style=color:#a6e22e>peek</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>peek</span> (x<span style=color:#66d9ef>:</span><span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> initialStack <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> topElement <span style=color:#f92672>=</span> peek initialStack
</span></span><span style=display:flex><span>  print topElement
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Assertions</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack1 <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> stack2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span>  assert (peek stack1 <span style=color:#f92672>==</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  assert (peek stack2 <span style=color:#f92672>==</span> <span style=color:#66d9ef>Nothing</span>)
</span></span></code></pre></div><p>The <code>peek</code> function is similar to <code>pop</code> in that it handles empty and non-empty stacks. However, instead of returning both the element and the new stack, it only returns the top element using <code>Just x</code> when the stack is not empty and <code>Nothing</code> when it&rsquo;s empty. Note the use of <code>_</code> to indicate that we don&rsquo;t need the tail of the list in this function.</p><h2 id=thoughts>Thoughts</h2><p>Here&rsquo;s the complete code implementing a simple stack in Haskell, combining all the solutions into a single snippet with the assert statements organized at the bottom:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>push</span> <span style=color:#f92672>::</span> a <span style=color:#f92672>-&gt;</span> [a] <span style=color:#f92672>-&gt;</span> [a]
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span> x stack <span style=color:#f92672>=</span> x <span style=color:#66d9ef>:</span> stack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> (a, [a])
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> (x<span style=color:#66d9ef>:</span>xs) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> (x, xs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>peek</span> <span style=color:#f92672>::</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> a
</span></span><span style=display:flex><span><span style=color:#a6e22e>peek</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Nothing</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>peek</span> (x<span style=color:#66d9ef>:</span><span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Just</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Example Usage</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> initialStack <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> newStack <span style=color:#f92672>=</span> push <span style=color:#ae81ff>4</span> initialStack
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> popped <span style=color:#f92672>=</span> pop newStack
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> topElement <span style=color:#f92672>=</span> peek newStack
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  print (<span style=color:#e6db74>&#34;Initial Stack: &#34;</span> <span style=color:#f92672>++</span> show initialStack)
</span></span><span style=display:flex><span>  print (<span style=color:#e6db74>&#34;New Stack (after push): &#34;</span> <span style=color:#f92672>++</span> show newStack)
</span></span><span style=display:flex><span>  print (<span style=color:#e6db74>&#34;Popped Element (and new stack): &#34;</span> <span style=color:#f92672>++</span> show popped)
</span></span><span style=display:flex><span>  print (<span style=color:#e6db74>&#34;Top Element (peek): &#34;</span> <span style=color:#f92672>++</span> show topElement)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Assertions</span>
</span></span><span style=display:flex><span>  assert (push <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>==</span> [<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>  assert (push <span style=color:#ae81ff>2</span> [<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> [<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>  assert (pop [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> <span style=color:#66d9ef>Just</span> (<span style=color:#ae81ff>1</span>,[<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>]))
</span></span><span style=display:flex><span>  assert (pop <span style=color:#66d9ef>[]</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>Nothing</span>)
</span></span><span style=display:flex><span>  assert (peek [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> <span style=color:#66d9ef>Just</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  assert (peek <span style=color:#66d9ef>[]</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>Nothing</span>)
</span></span></code></pre></div><p>This implementation provides a basic but functional stack in Haskell. The use of lists, pattern matching, and <code>Maybe</code> makes the code concise and idiomatic Haskell. Remember that these functions return <em>new</em> stacks instead of modifying the original one, which is consistent with Haskell&rsquo;s immutable nature. While the assertions provide rudimentary testing, consider using a proper testing framework like <code>Hspec</code> or <code>QuickCheck</code> for more thorough verification in real-world applications.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/haskell>Haskell</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/data-structures>Data Structures</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/stack>Stack</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/functional-programming>Functional Programming</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://tutorial-island.github.io/posts/article-20250419011616/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Reversing a String in JavaScript</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://tutorial-island.github.io/posts/article-20250417011909/><span>Implementing a Simple Text Analyzer in Python</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=tutorial-island/tutorial-island.github.io data-repo-id=R_kgDOOR40uQ data-category=Comments data-category-id=giscus-comments data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025<a class=link href=https://tutorial-island.github.io/>Tutorial Island</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>