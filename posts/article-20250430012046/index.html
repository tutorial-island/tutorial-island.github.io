<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Implementing a Simple Caesar Cipher in Haskell-Tutorial Island</title>
<meta name=theme-color><meta name=description content="Introduction
Today, we&rsquo;re going to implement a simple Caesar cipher in Haskell. A Caesar cipher is a type of substitution cipher where each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a shift of 3, &lsquo;A&rsquo; would be replaced by &lsquo;D&rsquo;, &lsquo;B&rsquo; would become &lsquo;E&rsquo;, and so on. This exercise will help you understand basic Haskell syntax, data types, and function definitions."><meta name=author content="Tutorial Island"><link rel="preload stylesheet" as=style href=https://tutorial-island.github.io/main.min.css><link rel=preload as=image href=https://tutorial-island.github.io/theme.png><link rel=preload as=image href=https://tutorial-island.github.io/rss.svg><script defer src=https://tutorial-island.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tutorial-island.github.io/favicon.ico><link rel=apple-touch-icon href=https://tutorial-island.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.147.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-8LQ7YJEW54"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8LQ7YJEW54")}</script><meta itemprop=name content="Implementing a Simple Caesar Cipher in Haskell"><meta itemprop=description content="A tutorial for junior Haskell developers on implementing a Caesar cipher, covering basic data types, functions, and recursion."><meta itemprop=datePublished content="2025-04-30T00:00:00+00:00"><meta itemprop=dateModified content="2025-04-30T00:00:00+00:00"><meta itemprop=wordCount content="959"><meta itemprop=keywords content="Haskell,Cipher,Recursion,Data Types,Beginner"><meta property="og:url" content="https://tutorial-island.github.io/posts/article-20250430012046/"><meta property="og:site_name" content="Tutorial Island"><meta property="og:title" content="Implementing a Simple Caesar Cipher in Haskell"><meta property="og:description" content="A tutorial for junior Haskell developers on implementing a Caesar cipher, covering basic data types, functions, and recursion."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-30T00:00:00+00:00"><meta property="article:tag" content="Haskell"><meta property="article:tag" content="Cipher"><meta property="article:tag" content="Recursion"><meta property="article:tag" content="Data Types"><meta property="article:tag" content="Beginner"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Simple Caesar Cipher in Haskell"><meta name=twitter:description content="A tutorial for junior Haskell developers on implementing a Caesar cipher, covering basic data types, functions, and recursion."><link rel=canonical href=https://tutorial-island.github.io/posts/article-20250430012046/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://tutorial-island.github.io/>Tutorial Island</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://tutorial-island.github.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Implementing a Simple Caesar Cipher in Haskell</h1><div class="text-xs antialiased opacity-60"><time>Apr 30, 2025</time><span class=mx-1>&#183;</span>
<span>Tutorial Island</span></div></header><section><h2 id=introduction>Introduction</h2><p>Today, we&rsquo;re going to implement a simple Caesar cipher in Haskell. A Caesar cipher is a type of substitution cipher where each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a shift of 3, &lsquo;A&rsquo; would be replaced by &lsquo;D&rsquo;, &lsquo;B&rsquo; would become &lsquo;E&rsquo;, and so on. This exercise will help you understand basic Haskell syntax, data types, and function definitions.</p><h2 id=explanation>Explanation</h2><p>The Caesar cipher presents a few challenges:</p><ol><li><strong>Handling Character Encoding:</strong> We need to represent letters as numbers to perform the shift and then convert them back to letters. We will use the <code>Char</code> data type and functions like <code>ord</code> and <code>chr</code> for this.</li><li><strong>Wrapping Around the Alphabet:</strong> If we shift a letter near the end of the alphabet, we need to wrap around to the beginning. We&rsquo;ll use the modulo operator (<code>rem</code>) to handle this.</li><li><strong>Handling Case and Non-Alphabetic Characters:</strong> We should ideally preserve the case of the input letters and leave non-alphabetic characters unchanged. We&rsquo;ll use pattern matching and conditional logic to achieve this.</li><li><strong>Recursion:</strong> Haskell promotes recursive solutions, so we&rsquo;ll use recursion to process the entire input string.</li></ol><p>We&rsquo;ll use the following Haskell features:</p><ul><li><code>Char</code> and <code>String</code> data types.</li><li><code>ord</code> and <code>chr</code> functions for character encoding/decoding.</li><li><code>rem</code> for the modulo operation.</li><li>Function definition and pattern matching.</li><li>Recursion.</li><li>Conditional statements (if-then-else or guards).</li></ul><h2 id=requirements>Requirements</h2><ul><li><strong>Functional Requirement 1:</strong> Implement a function that takes a string and a shift value as input and returns the Caesar-ciphered string.</li><li><strong>Functional Requirement 2:</strong> Preserve the case (uppercase/lowercase) of the letters.</li><li><strong>Functional Requirement 3:</strong> Leave non-alphabetic characters unchanged.</li><li><strong>Non-Functional Requirement 1:</strong> The code should be readable and well-documented.</li></ul><h2 id=solutions>Solutions</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- Function to shift a single character</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftChar</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftChar</span> shift char <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> isLetter char
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>then</span> shiftLetter shift char
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> char
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    isLetter c <span style=color:#f92672>=</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;Z&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Shifts letters with modular arithmetic</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftLetter</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftLetter</span> shift char <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> base <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> isLower char <span style=color:#66d9ef>then</span> ord <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>else</span> ord <span style=color:#e6db74>&#39;A&#39;</span>
</span></span><span style=display:flex><span>        isLower c <span style=color:#f92672>=</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>
</span></span><span style=display:flex><span>        newCode <span style=color:#f92672>=</span> (ord char <span style=color:#f92672>-</span> base <span style=color:#f92672>+</span> shift) `rem` <span style=color:#ae81ff>26</span> <span style=color:#f92672>+</span> base
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> chr newCode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Example Usage/Tests</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- Test Case 1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> shiftedA <span style=color:#f92672>=</span> shiftLetter <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span>    print shiftedA
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- Test Case 2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> shiftedZ <span style=color:#f92672>=</span> shiftLetter <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#39;z&#39;</span>
</span></span><span style=display:flex><span>    print shiftedZ
</span></span></code></pre></div><p><em>Explanation:</em></p><ul><li><code>shiftChar</code>: This function takes a shift value and a character as input. It checks if the character is a letter (uppercase or lowercase). If it is, it calls <code>shiftLetter</code> to perform the shift. Otherwise, it returns the character unchanged. This addresses <strong>Functional Requirement 3</strong>. We achieve this check by creating a predicate <code>isLetter</code> that determines if the character is within <code>a-z</code> or <code>A-Z</code>.</li><li><code>shiftLetter</code>: This function performs the actual shift on a letter. It determines the base ASCII value (&lsquo;a&rsquo; for lowercase, &lsquo;A&rsquo; for uppercase) and then calculates the new ASCII code using the modulo operator (<code>rem</code>) to wrap around the alphabet. Finally, it converts the new ASCII code back to a character using <code>chr</code>. This addresses <strong>Functional Requirement 2</strong> and implements the core Caesar cipher logic. It uses <code>isLower</code> predicate that determines if a character is lowercase or uppercase to select the base.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- Function to encrypt the entire string using recursion</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> shift (char<span style=color:#66d9ef>:</span>rest) <span style=color:#f92672>=</span> shiftChar shift char <span style=color:#66d9ef>:</span> caesarCipher shift rest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Example Usage/Tests</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result1 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>  print result1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result2 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;def&#34;</span>
</span></span><span style=display:flex><span>  print result2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> result3 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>  print result3
</span></span></code></pre></div><p><em>Explanation:</em></p><ul><li><code>caesarCipher</code>: This function takes a shift value and a string as input. It uses recursion to process each character in the string. For each character, it calls <code>shiftChar</code> to shift the character and then prepends the shifted character to the result of recursively calling <code>caesarCipher</code> on the rest of the string. The base case for the recursion is an empty string, which simply returns an empty string. This addresses <strong>Functional Requirement 1</strong> and elegantly handles the entire string using recursion.</li></ul><h2 id=thoughts>Thoughts</h2><p>Here&rsquo;s the complete Caesar cipher implementation, combining the individual components:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- Function to shift a single character</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftChar</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftChar</span> shift char <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> isLetter char
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>then</span> shiftLetter shift char
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> char
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    isLetter c <span style=color:#f92672>=</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span> <span style=color:#f92672>||</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;Z&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Shifts letters with modular arithmetic</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftLetter</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>shiftLetter</span> shift char <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> base <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> isLower char <span style=color:#66d9ef>then</span> ord <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#66d9ef>else</span> ord <span style=color:#e6db74>&#39;A&#39;</span>
</span></span><span style=display:flex><span>        isLower c <span style=color:#f92672>=</span> c <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>
</span></span><span style=display:flex><span>        newCode <span style=color:#f92672>=</span> (ord char <span style=color:#f92672>-</span> base <span style=color:#f92672>+</span> shift) `rem` <span style=color:#ae81ff>26</span> <span style=color:#f92672>+</span> base
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> chr newCode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Function to encrypt the entire string using recursion</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>caesarCipher</span> shift (char<span style=color:#66d9ef>:</span>rest) <span style=color:#f92672>=</span> shiftChar shift char <span style=color:#66d9ef>:</span> caesarCipher shift rest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Main function for tests</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> test1 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>  print test1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> test2 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;def&#34;</span>
</span></span><span style=display:flex><span>  print test2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> test3 <span style=color:#f92672>=</span> caesarCipher <span style=color:#ae81ff>3</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>  print test3
</span></span></code></pre></div><p>This implementation demonstrates how to solve a problem by breaking it down into smaller, manageable functions. We used recursion, conditional logic, and basic character manipulation techniques to implement the Caesar cipher in a clear and concise way. This exercise provides a good foundation for understanding more complex algorithms and data structures in Haskell. Remember to compile and run the code to see the results and experiment with different shift values and input strings.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/haskell>Haskell</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/cipher>Cipher</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/recursion>Recursion</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/data-types>Data Types</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://tutorial-island.github.io/tags/beginner>Beginner</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://tutorial-island.github.io/posts/article-20250501012733/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Implementing a Simple Number Checker in C#</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://tutorial-island.github.io/posts/article-20250429012041/><span>Implementing a Simple Caesar Cipher in C#</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=tutorial-island/tutorial-island.github.io data-repo-id=R_kgDOOR40uQ data-category=Comments data-category-id=giscus-comments data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025<a class=link href=https://tutorial-island.github.io/>Tutorial Island</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>